# Decorator パターン

## 概要

- 基本となる機能を持ったクラスから機能を追加していくパターン

## 重要ポイント

- 飾り枠と中身の同一視
  - 飾り枠と中身が抽象クラスを継承していることで、同一視可能になる
- 透過的な API
  - 飾り枠は中身の API を継承するため、どこからでも核となる機能が呼べる
  - API が隠されずどのクラスからでも見えているため、API が透過的であると言える
- Composite パターンと同様、再帰的な階層構造を持つことができる
  - ただし、Decorator パターンは機能の追加が目的であるため、意図が異なる
- 中身を変えずに機能追加ができる
  - 包まれている中身を変えることなく機能追加が可能
  - 飾り枠が中身に委譲しているため
- 多様な機能追加ができる
  - 単純な機能を個別に飾り枠にすることで、機能追加が必要になった際に作成済みの飾り枠を組み合わせて対応できる
  - 検証等ですぐに機能を追加したい、切替えたいといった場合に便利

## 注意点

- 似たようなクラスが増えがち
  - 単純な機能を持った似たようなクラスが多量に生成されることになるため、管理が大変になる（かも）

## クラス一覧

- Component クラス(Display)
  - 基本機能を保持した核となるクラス
  - API のみを定義する
- ConcreteComponent クラス(StringDisplay)
  - Component クラスの機能を実装したクラス
- Decorator クラス(Border)
  - Component クラスの API を所持する
  - さらに、機能を追加する Component クラスのインスタンスを保持する
- ConcreteDecorator クラス(SideBorder, FullBorder)
  - Decorator クラスの API を実装したクラス
  - 機能を実装する際は、Component クラスのメソッドを呼び出しつつ、処理を足す

## 委譲と継承の同一視について

### 継承の場合

- サブクラスとスーパークラスを同一視する
  - サブクラスのインスタンスをスーパークラスとして扱うことができる
  - 逆を行う場合はキャストが必要

### 委譲の場合

- 自身と委譲先を同一視する
